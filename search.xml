<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图像序列转成视频文件-Python代码</title>
      <link href="/2021/12/23/%E5%9B%BE%E5%83%8F%E5%BA%8F%E5%88%97%E8%BD%AC%E6%88%90%E8%A7%86%E9%A2%91-%E4%BB%A3%E7%A0%81/"/>
      <url>/2021/12/23/%E5%9B%BE%E5%83%8F%E5%BA%8F%E5%88%97%E8%BD%AC%E6%88%90%E8%A7%86%E9%A2%91-%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>把一组带有图片序列文件的文件夹，用python合成视频文件，并可以对图片序列文件进行排序，防止合成错乱。</p><h2 id="依赖库："><a href="#依赖库：" class="headerlink" title="依赖库："></a>依赖库：</h2><ul><li>opencv-python</li><li>unicodedata</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="python">#coding:utf-8import cv2import os# 获取当前目录os.chdir(os.path.split(os.path.realpath(__file__))[0])print(os.getcwd())def is_number(s):    &quot;&quot;&quot;判断是不是数字    &quot;&quot;&quot;    try:        float(s)        return True    except ValueError:        pass     try:        import unicodedata        unicodedata.numeric(s)        return True    except (TypeError, ValueError):        pass     return False  def find_continuous_num(astr, c):    &quot;&quot;&quot;寻找连续数字    &quot;&quot;&quot;    num = &#39;&#39;    try:        while not is_number(astr[c]) and c &lt; len(astr):            c += 1        while is_number(astr[c]) and c &lt; len(astr):            num += astr[c]            c += 1    except:        pass    if num != &#39;&#39;:        return int(num)  def comp2filename(file1, file2):    &quot;&quot;&quot;比较文件名称    &quot;&quot;&quot;    smaller_length = min(len(file1), len(file2))    for c in range(0, smaller_length):        if not is_number(file1[c]) and not is_number(file2[c]):            # print(&#39;both not number&#39;)            if file1[c] &lt; file2[c]:                return True            if file1[c] &gt; file2[c]:                return False            if file1[c] == file2[c]:                if c == smaller_length - 1:                    # print(&#39;the last bit&#39;)                    if len(file1) &lt; len(file2):                        return True                    else:                        return False                else:                    continue        if is_number(file1[c]) and not is_number(file2[c]):            return True        if not is_number(file1[c]) and is_number(file2[c]):            return False        if is_number(file1[c]) and is_number(file2[c]):            if find_continuous_num(file1, c) &lt; find_continuous_num(file2, c):                return True            else:                return False            def sort_insert_filename(file_list):    &quot;&quot;&quot;对文件名称进行排序，保证数字的连续性    &quot;&quot;&quot;    for i in range(1, len(file_list)):        x = file_list[i]        j = i        while j &gt; 0 and comp2filename(x, file_list[j-1]):            file_list[j] = file_list[j-1]            j -= 1        file_list[j] = x    return file_listdef img2video(img_root, dst_name, fps=24):    &quot;&quot;&quot;将一组图片序列转化为视频文件    Args:        img_root (str): 图片序列的文件夹地址        dst_name ([type]): 输出的视频文件地址        fps (int, optional): 输出视频序列的帧数. Defaults to 24.    &quot;&quot;&quot;    img_list = os.listdir(image_root)    img_list = sort_insert_filename(img_list)    print(img_list)    if len(img_list) &gt; 0:        # 检测图片的长和宽        img = cv2.imread(os.path.join(image_root, img_list[0]))        w,h = img.shape[1],img.shape[0]    else:        raise Exception(&quot;no image in &#123;&#125;&quot;.format(image_root))    fps = fps    fourcc = cv2.VideoWriter_fourcc(*&#39;XVID&#39;)    video_writer = cv2.VideoWriter(filename=dst_name, fourcc=fourcc, fps=fps, frameSize=(w,h))    for img_path in img_list:        # 逐张写入视频        path = os.path.join(image_root, img_path)        if os.path.exists(path):    #判断图片是否存在            img = cv2.imread(filename=path)        else:            continue        cv2.waitKey(10)        video_writer.write(img)        print(img_path + &#39; done!&#39;)    video_writer.release()if __name__ == &#39;__main__&#39;:    image_root = &#39;./merged_face/&#39;    dst_name = &#39;./merged_face_test.mp4&#39;    fps = 24    img2video(image_root,dst_name,fps=fps)    print(&#39;finished&#39;)    # 测试文件列表排序    # print(sort_insert_filename([&#39;a09&#39;, &#39;a2&#39;, &#39;b2&#39;, &#39;a10&#39;,&#39;a100&#39;, &#39;a01&#39;, &#39;a010&#39;, &#39;_a3&#39;, &#39;a893&#39;, &#39;a90&#39;]))</code></pre>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 图像 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blendshape Retargeting 入门笔记</title>
      <link href="/2021/12/22/blendshape%20retargeting%20%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0%E6%95%B4%E7%90%86/"/>
      <url>/2021/12/22/blendshape%20retargeting%20%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>这里的blendshape指的是人脸模型表情的表示方式，所以这是一篇关于模型表情的笔记</li><li>本篇笔记主要关注算法上的实现，而不是CG或3D软件，如maya，ue等软件上的实现。</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Blendshape Retargeting,  被称为<strong>表情重定向</strong>问题，指的是将一个人脸模型的表情迁移到另一个模型上。包括真实人脸的表情迁移到3D人脸模型上，或者把A人脸模型的表情迁移到B人脸模型上。比如电影中，用真人来驱动阿凡达的脸部表情，就是一个表情重定向的过程。PS：在这里，默认为人脸模型的表情由Blendshape驱动。</p><p><strong>TODO</strong>：放图</p><h2 id="一些基础知识"><a href="#一些基础知识" class="headerlink" title="一些基础知识"></a>一些基础知识</h2><h3 id="1-表情和Blendshape的关系"><a href="#1-表情和Blendshape的关系" class="headerlink" title="1. 表情和Blendshape的关系"></a>1. 表情和Blendshape的关系</h3><ul><li>现在业界在做表情动画时，都是基于blendshape或者骨骼来实现，大部分还是偏向用blendshape来做表情，因为操作起来会更方便一些。</li><li>每个模型会做一系列的基表情，比如闭眼、张嘴等，这样，从一个自然的表情到闭眼的基表情之间，做一个blendshape，就形成了眨眼的表情动画效果。</li></ul><p><strong>TODO</strong>：补基表情的图</p><ul><li>blendshape和表情动画的数学表示<ul><li>将表情模型看做 $N$ 个表情基模型：$B=[b_0,…,b_N]$, $b_0$ 可以看作无任何表情的中性表情。每一个基表情都会对应一个表情系数 $E=[e_0,…,e_N]$，组合起来就形成了各种各样的表情：<br>$$<br>F = b_0+\sum^{N}_{i}e_i(b_i-b_0), e_i\in[0,1]<br>$$</li></ul></li></ul><h3 id="2-常用的blendshape标准"><a href="#2-常用的blendshape标准" class="headerlink" title="2. 常用的blendshape标准"></a>2. 常用的blendshape标准</h3><ul><li>通用的是51维blendshape<ul><li>包括eyeblink, eyeopen, jawopen, liptogether等维度</li></ul></li><li>苹果标准<ul><li><a href="https://developer.apple.com/documentation/arkit/arfaceanchor/2928251-blendshapes">https://developer.apple.com/documentation/arkit/arfaceanchor/2928251-blendshapes</a></li></ul></li></ul><h3 id="3-拓扑结构是什么"><a href="#3-拓扑结构是什么" class="headerlink" title="3. 拓扑结构是什么"></a>3. 拓扑结构是什么</h3><ul><li>拓扑结构一般指顶点数、三角面片数和三角面片连接关系</li></ul><h3 id="4-稀疏表示和稀疏编码"><a href="#4-稀疏表示和稀疏编码" class="headerlink" title="4. 稀疏表示和稀疏编码"></a>4. 稀疏表示和稀疏编码</h3><ul><li>有时会遇到稀疏表示的问题，可以参考下列文章</li><li><a href="https://www.pianshen.com/article/74041446901/">https://www.pianshen.com/article/74041446901/</a></li></ul><h2 id="一些有用的文章或博客"><a href="#一些有用的文章或博客" class="headerlink" title="一些有用的文章或博客"></a>一些有用的文章或博客</h2><h3 id="论文："><a href="#论文：" class="headerlink" title="论文："></a>论文：</h3><ul><li><a href="http://www.scribblethink.org/Work/Pdfs/blendshapes_MAIN.pdf">Practice and Theory of Blendshape Facial Models</a>（入门级文章，主要讲解blendshape的一些基本知识）</li><li><a href="http://www.cs.unc.edu/~jdh/documents/thesis_master.pdf">基于变形迁移的表情克隆及其应用</a>（中科院硕士论文，可以当基础知识来看）</li></ul><h3 id="博客："><a href="#博客：" class="headerlink" title="博客："></a>博客：</h3><ul><li><a href="https://blog.csdn.net/zb1165048017/article/details/115491531">卡通角色表情驱动系列一</a>  （讲解表情驱动的博客）</li><li><a href="https://blog.csdn.net/zb1165048017/article/details/118864029">卡通角色表情驱动系列二</a>  （讲解网格变形的博客）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 未完工 </tag>
            
            <tag> 表情动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/12/21/Hello%20World/"/>
      <url>/2021/12/21/Hello%20World/</url>
      
        <content type="html"><![CDATA[<h2 id="出发"><a href="#出发" class="headerlink" title="出发"></a>出发</h2><p>2021年冬至。</p><p>第一篇献给Hello World。</p><p>放弃CSDN，转战Hexo，希望自己可以坚持下来，产出一些真正有用的内容。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
